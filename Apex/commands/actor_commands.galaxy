//=========================================================
//		Apex Roleplaying Engine
//		Copyright (c) 2022, Apex Group
//=========================================================
// This software is distributed under the MIT License:
// <http://opensource.org/licenses/MIT>
//=========================================================

// Actor commands are implemented by actor messages and affect visuals
// General format for every actor command is
//      @cmd ->[target] [parameters ...]
// The ->[target] (or __[target]) is an optional actor reference as the
// target for an actor message send (defaults to ::Main which refers to the
// main actor for a unit)
//     ->[target] : local scope (confined to a single unit)
//     __[target] : global scope, refers to generic actor reference name
// The rest of the command is its unique parameter list

// Main actor for unit (default actor reference target)
static string LibapxACTORREFMAIN = "->::Main";




// LibapxHasActorRef
// ===================
// Helper function to check if a paramater is a proper actor reference
// Syntax for reference and scope are:
//      >  "__[target]" : global reference
//      >  "->[target]" : local reference (single unit)
static bool LibapxHasActorRef(string ref) {
	string scope;
	if( ref != "" ) { // disregard if ref is invalid
		scope = StringSub(ref, 1, 2);
		if( scope == "__" || scope == "->" ) {
			return true;
		}
	}

	return false;
}

// ApplyActormsg
// ======================
// Generic function to apply the internal actor msg to a group of units
// -> normally group of units will be the player context (units selected)
// Certain actor commands require special casing for the actor msgs applied,
// in which case this block is special cased in the actor command
// function (Galaxy highly limited in dealing with generic functions)
static void ApplyActormsg(unitgroup g, string target, string argv, string cmd, string amsg) {
	if( StringSub(target, 1, 2) == "->" ) {
		target = StringSub(target, 3, StringLength(target));
		UnitGroupLoopBegin(g);
		while(!UnitGroupLoopDone()) {
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), target, amsg);
			LibapxUnitCacheUpdate(UnitGroupLoopCurrent(), cmd, argv);
			UnitGroupLoopStep();
		}
		UnitGroupLoopEnd();
	}
	else { // "__[ref]", target global
		target = StringSub(target, 3, StringLength(target));
		UnitGroupLoopBegin(g);
		while(!UnitGroupLoopDone()) {
			ActorSend(ActorFrom(target), amsg);
			UnitGroupLoopStep();
		}
		UnitGroupLoopEnd();
	}
}

// LibapxCommandActormessage
// =======================
// Sends an ActorMessage to a unit (main or a actor reference) or to a global reference
// Optional reference is either ->[reference] for local scope (within a unit scope)
//							or	__[reference] for global scope (any actor on map)
// Syntax: @actrmsg ->/__[reference] [msg]
//
// An issue that isn't easily dealt with is that actor messages are
// case sensitive. Only way to allow case insensitive user inputs is to manually
// match user input to actual actor messages (many elseif), which is shitty
//
// TODO: convert to new generalized amsg target system?
void LibapxCommandActormessage(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	unitgroup g = u;
	string target = StringWord( argv, 2);
	bool targetScopeGlobal = false;
	string amsg;
	int amsgStartWordIndex = 1;
	int amsgStartIndex;
	unitgroup p = u;
	int colcheker = 1;
	bool colFlag = false;
	bool nocache = false;

	if (StringContains(argv,"-nocache",c_stringAnywhere,c_stringNoCase)) {
		nocache = true;
		argv = StringReplaceWord(argv," -nocache","",1,c_stringNoCase);
	}
	
	while (StringWord(argv, colcheker) != "") {
		if(StringFind(StringWord(argv, colcheker), "colossus", c_stringNoCase) != -1 ) {
				UnitGroupLoopBegin(p);
				while(!UnitGroupLoopDone()) {
					LibapxUnitFlagColossus(UnitGroupLoopCurrent());
					UnitGroupLoopStep();
				}
				UnitGroupLoopEnd();
		}
		colcheker = colcheker + 1;
	}
	if(target == "") {
		return;
	}

	// check the actor message target:
	// target is specified by @actrmsg ->[Target] [msg] OR @actrmsg __[Target] [msg]
	// e.g. @actrmsg ->Unit SetTint 250,0,0 or @actrmsg ->::Main SetTint 250,0,0
	// default will use target ::Main (the main actor for a unit)
	// -> indicates local scope (unit actor) whereas __ indicates a global scope
	else if( StringSub(target,1,2) == "__" ) {
		target = StringSub(target, 3, StringLength(target));
		amsgStartWordIndex = 2;
		targetScopeGlobal = true;
	}
	else if( StringSub(target,1,2) == "->" ) {
		target = StringSub(target, 3, StringLength(target));
		amsgStartWordIndex = 2;
	}
	else { // default target is ::Main (local unit scope)
		target = "::Main";
	}

	// get the actor message string (remainder of line)
	amsgStartIndex = StringLength(StringWord( argv, 1)) + 2;
	if( amsgStartWordIndex == 2 ) {
		amsgStartIndex += StringLength(StringWord( argv, 2)) + 1;
	}

	amsg = StringSub( argv, amsgStartIndex, StringLength(argv));

	if (StringWord(amsg,1) == "SetScale" || StringWord(amsg,1) == "SetScaleAbsolute") {

		amsg = StringWord(amsg,1) +  " " + LibapxScalerapply(StringWord(amsg,2), u, "scale", user) + " " + StringWord(amsg,3) + " " + StringWord(amsg,4); // @actrmsg SetScale 3 1.000000 Label;@actrmsg ClearScale 1.000000 Label
	}
	//LibapxScalerapply(offset)

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		if( targetScopeGlobal ) {
			ActorSend(ActorFrom(target), amsg);
		}
		else {
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), target, amsg);
			if(!nocache) {
				LibapxUnitCacheUpdate(UnitGroupLoopCurrent(), "@actrmsg", argv);
			}
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return;
}
void LibapxDefineActormessage(string commandName) {
	LibapxCommandsGuideEntrySet(
		gv_CommandsGuideEntryActor, 
		commandName, 
		" Sends an ActorMessage to an actor, a target can be used with this command. <br> @actrmsg ->target actormessage <br> Examples: <br> @actrmsg SetTeamColor {255,0,0 3} {3,5,255 5} <br> @actrmsg SetScaleAbsolute 4 "
	);
}

// LibapxCommandActoralias
// =======================
// wrapper for the AliasAdd actor msg to add actor aliases to a unit's actors.
// These can be referenced as actor references by other actor commands
// using ->[ref]
// syntax: @actoralias (->[ref]) [alias]
void LibapxCommandActoralias(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	string actoralias;
	int paramOffset = 0;
	string target = LibapxACTORREFMAIN;

	// get actor reference target
	if( LibapxHasActorRef(StringWord(argv, 2)) ) {
		target = StringWord(argv, 2);
		paramOffset = 1;
	}

	// get actor alias
	actoralias = StringWord(argv, 2 + paramOffset);
	if( actoralias == "" ) {
		LibapxPrintError(user, "Actor alias cannot be blank");
		return;
	}

	ApplyActormsg(u, target, argv, "@target", "AliasAdd " + actoralias);
	LibapxUnitCacheUpdate(UnitGroupLoopCurrent(), "@target", argv);
	return;
}
void LibapxDefineTarget(string commandName) {
	LibapxCommandsGuideEntrySet(
		gv_CommandsGuideEntryActor, 
		commandName, 
		" Gives an actor a target or name to be used to point to this actor with another command, a target can also be used with this command. <br> @target ->target targetname <br> Examples: <br> @target 123;@attach marine origin 0 0 3;@scale ->123 3 3 3 <br> @target ->b 123 <br> <br> Extra Info: <br> You can remove a target by doing <br> @actrmsg ->targetyouwanttoremove AliasRemove ->targetyouwanttoremove <br> @actrmsg ->::Main -nocache SetScale 2 1 Steven "
	);
}



// LibapxCommandScale
// ====================
// sets the scale of a unit's main actor for all units in context (modified from Cortex Engine)
// Syntax: @scale (->[ref]) [x] [y] [z] [time-blend]
void LibapxCommandScale(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	fixed x = 0;
	fixed y = 0;
	fixed z  = 0;
	fixed time = 0;
	string paramX;
	string paramY;
	string paramZ;
	string paramTime;
	string scale;
	int paramOffset = 0;
	string target = LibapxACTORREFMAIN;
	string scaleLabel = ""; // This allows it to be cleared over a set duration using ClearScale. Giving a label allows multiple scales to stack on different labeled @scales (setscaler bypasses large numbers anyways). Example: @scale 2 2 2 1.00000 scaleLabel;@actrmsg ClearScale 1.000000 scaleLabel

	// get actor reference target
	if( LibapxHasActorRef(StringWord(argv, 2)) ) {
		target = StringWord(argv, 2);
		paramOffset = 1;
	}

	// get scale params "x y z time"
	paramX = StringWord(argv, 2 + paramOffset);
	paramY = StringWord(argv, 3 + paramOffset);
	paramZ = StringWord(argv, 4 + paramOffset);
	paramTime = StringWord(argv, 5 + paramOffset);
	scaleLabel = StringWord(argv, 6 + paramOffset);

	x = StringToFixed(paramX);
	y = StringToFixed(paramY);
	z = StringToFixed(paramZ);

	if(y == 0.0) {
		y = x;
	}

	if(z == 0.0) {
		z = x;
	}

	// verify bounds.
	x = MinF( gv_LibapxSettings.maxScale, x );
	x = MaxF( gv_LibapxSettings.minScale, x );

	y = MinF( gv_LibapxSettings.maxScale, y );
	y = MaxF( gv_LibapxSettings.minScale, y );

	z = MinF( gv_LibapxSettings.maxScale, z );
	z = MaxF( gv_LibapxSettings.minScale, z );

	// get blend time
	if( paramTime != "" ) {
		time = StringToFixed(paramTime);
	}
	scale = FixedToString(x, 4) + "," + FixedToString(y, 4)  + "," + FixedToString(z, 4);
	scale = LibapxScalerapply(scale, u, "scale", user); //Applies scaler


	ApplyActormsg(u, target, argv, "@scale",
						  "SetScale " + scale + " " + FixedToString(time, 3) + " " + scaleLabel);
	return;
}
void LibapxDefineScale(string commandName) {
	LibapxCommandsGuideEntrySet(
		gv_CommandsGuideEntryActor, 
		commandName, 
		" Changes the scale of an actor. It can be used with target. <br> @scale ->target x y z timescale <br> Examples: <br> @scale 3 2 1 4 <br> @scale 3 <br> @target a;@attach marine head;@scale ->a 5 5 1 3 <br> @scale 3 3 3 0 Name;@actrmsg ClearScale 1.000000 Name "
	);
}


// LibapxCommandTint
// =================
// sets the tint of a unit's main actor for all units in context
// Syntax: @tint (->[ref]) [R] [G] [B] [Opacity] [HDR] [time-blend]
// (modified from Cortex Engine)
void LibapxCommandTint(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	string paramR;
	string paramG;
	string paramB;
	string paramAlpha;
	string paramHDR;
	string paramT;
	// default parameters for @tint without any inputs are below
	int red = 0;
	int green = 0;
	int blue = 0;
	fixed alpha = 1.0;
	fixed hdr = 1.0;
	fixed duration = 0;

	unitgroup g = u;
	int paramOffset = 0;
	string target = LibapxACTORREFMAIN;

	// get actor reference target
	if( LibapxHasActorRef(StringWord(argv, 2)) ) {
		target = StringWord(argv, 2);
		paramOffset = 1;
	}

	paramR = StringWord(argv, 2 + paramOffset);
	paramG = StringWord(argv, 3 + paramOffset);
	paramB = StringWord(argv, 4 + paramOffset);
	paramAlpha = StringWord(argv, 5 + paramOffset);
	paramHDR = StringWord(argv, 6 + paramOffset);
	paramT = StringWord(argv, 7 + paramOffset);

	// get red input
	if( paramR != "" ) {
		if( StringContains(paramR, "%", c_stringEnd, false) ) {
			paramR = StringSub(paramR, 1, StringLength(paramR)-1);
			red = FixedToInt( 255.0 * StringToFixed(paramR)/100.0 );
		} else {
			red = StringToInt(paramR);
		}
	}

	// get green input
	if( paramG != "" ) {
		if( StringContains(paramG, "%", c_stringEnd, false) ) {
			paramG = StringSub(paramG, 1, StringLength(paramG)-1);
			green = FixedToInt( 255.0 * StringToFixed(paramG)/100.0 );
		} else {
			green = StringToInt(paramG);
		}
	}

	// get blue input
	if( paramB != "" ) {
		if( StringContains(paramB, "%", c_stringEnd, false) ) {
			paramB = StringSub(paramB, 1, StringLength(paramB)-1);
			blue = FixedToInt( 255.0 * StringToFixed(paramB)/100.0 );
		} else {
			blue = StringToInt(paramB);
		}
	}

	// get alpha (opacity), from 0 to 1
	if( paramAlpha != "" ) {
		if( StringContains(paramAlpha, "%", c_stringEnd, false) ) {
			paramAlpha = StringSub(paramAlpha, 1, StringLength(paramAlpha)-1);
			alpha = StringToFixed(paramAlpha)/100.0;
		} else {
			alpha = StringToFixed(paramAlpha);
		}
	}
	//reset to 255
	if (red >= 255) {
		red = 255;
	}
	if (blue >= 255) {
		blue = 255;
	}
	if (green >= 255) {
		green = 255;
	}

	// get HDR
	if( paramHDR != "" ) {
		hdr = StringToFixed(paramHDR);
	}

	// get blend time
	if( paramT != "" ) {
		duration = StringToFixed(paramT);
	}

	// apply tint actor msg to units
	if( StringSub(target, 1, 2) == "->" ) {
		target = StringSub(target, 3, StringLength(target));
		UnitGroupLoopBegin(g);
		while(!UnitGroupLoopDone()) {
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), target,
						"SetTintColor {" + IntToString(red) + "," + IntToString(green) + "," + IntToString(blue) + " " +
						FixedToString(hdr, c_fixedPrecisionAny) + "} {" + FixedToString(duration, c_fixedPrecisionAny) + "}");
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), target,
						"SetOpacity {" + FixedToString(alpha, c_fixedPrecisionAny) + "} {" + FixedToString(duration, c_fixedPrecisionAny) + "}");
			LibapxUnitCacheUpdate(UnitGroupLoopCurrent(), "@tint", argv);
			UnitGroupLoopStep();
		}
		UnitGroupLoopEnd();
	}
	else { // "__[ref]", target global
		target = StringSub(target, 3, StringLength(target));
		UnitGroupLoopBegin(g);
		while(!UnitGroupLoopDone()) {
			ActorSend(ActorFrom(target),
						"SetTintColor {" + IntToString(red) + "," + IntToString(green) + "," + IntToString(blue) + " " +
						FixedToString(hdr, c_fixedPrecisionAny) + "} {" + FixedToString(duration, c_fixedPrecisionAny) + "}");
			ActorSend(ActorFrom(target),
						"SetOpacity {" + FixedToString(alpha, c_fixedPrecisionAny) + "} {" + FixedToString(duration, c_fixedPrecisionAny) + "}");
			UnitGroupLoopStep();
		}
		UnitGroupLoopEnd();
	}

	return;
}
void LibapxDefineTint(string commandName) {
	LibapxCommandsGuideEntrySet(
		gv_CommandsGuideEntryActor, 
		commandName, 
		" This command changes the tint of an actor. It can be used with target. <br> @scale ->[target] [r] [g] [b] [Opacity] [HDR] [timescale] <br> Examples: <br> @tint 255 0 0 <br> @tint 0 255 255 1 3 <br> @tint 255 255 255 .3 <br> @tint 255 255 255 1 15 5  "
	);
}


// LibapxCommandDecal
// ===================
// Changes the decal of an actor using TextureByID
// Syntax: @decal [decalname]
void LibapxCommandDecal(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	string decal;
	string amsg;
	int paramOffset = 0;
	string target = LibapxACTORREFMAIN;


	// get actor reference target
	if( LibapxHasActorRef(StringWord(argv, 2)) ) {
		target = StringWord(argv, 2);
		paramOffset = 1;
	}

	decal = LibapxCatalogGet(c_gameCatalogTexture, StringWord(argv, 2 + paramOffset));
	if(decal == null) {
		LibapxPrintOutput(user, "<c val=\"ff0000\">Unable to change decal</c>: No such decal exists.");
		return;
	}

	amsg = "TextureSelectById {" + decal + "}";
	ApplyActormsg(u, target, argv, "@decal", amsg);

	return;
}
void LibapxDefineDecal(string commandName) {
	LibapxCommandsGuideEntrySet(
		gv_CommandsGuideEntryActor, 
		commandName, 
		" Changes the decal of an actor, can be used with target. <br> @decal ->[target] [image] <br> Examples: <br> @decal decalNone <br> @target a;@attach marine weapon;@decal ->a  "
	);
}


// LibapxCommandModelswap
// ======================
// Changes the model of the main actor of unit (modified from Cortex Engine)
// Syntax: @modelswap (->[ref]) [model] [variation]
void LibapxCommandModelswap(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	string model;
	string variation;
	string amsg;
	int paramOffset = 0;
	string target = LibapxACTORREFMAIN;
	bool nosplice = false;
	string preventSplice = "";




	//colossus check
  	unitgroup p = u;
	int colcheker = 1;
	bool colFlag = false;
	while (StringWord(argv, colcheker) != "") {
		if(StringFind(StringWord(argv, colcheker), "colossus", c_stringNoCase) != -1 ) {
				UnitGroupLoopBegin(p);
				while(!UnitGroupLoopDone()) {
					LibapxUnitFlagColossus(UnitGroupLoopCurrent());
					UnitGroupLoopStep();
				}
				UnitGroupLoopEnd();
		}
		colcheker = colcheker + 1;
	}

	if (StringContains(argv,"-nosplice",c_stringAnywhere,c_stringNoCase)) {
		nosplice = true;
		// 100 is arbitrary, variation will be randomized if the given number is larger than the model's max variant count
		preventSplice = " {100} {PreventAllDynamicTextureTransfers}";
	}





	// get actor reference target
	if( LibapxHasActorRef(StringWord(argv, 2)) ) {
		target = StringWord(argv, 2);
		paramOffset = 1;
	}

	model = LibapxCatalogGet(c_gameCatalogModel, StringWord(argv, 2 + paramOffset));
	if(model == null) {
		LibapxPrintOutput(user, "<c val=\"ff0000\">Unable to swap model</c>: No such model exists.");
		return;
	}
	amsg = "ModelSwap {" + model + "} " + preventSplice;
	

	variation = StringWord(argv, 3 + paramOffset);
	if( variation != "" && StringToInt(variation) >= 0 && variation != "-nosplice") {
		amsg += " {" + variation + "}" + preventSplice;
	}

	ApplyActormsg(u, target, argv, "@modelswap", amsg);

	return;
}
void LibapxDefineModelswap(string commandName) {
	LibapxCommandsGuideEntrySet(
		gv_CommandsGuideEntryActor, 
		commandName, 
		" This command changes the model of an actor. It can be used with target. <br> @modelswap ->[target] [modelname] [variation] <br> Examples: <br> @modelswap Beacon_Apex <br> @modelswap HavenTree 02 <br> @target 123;@attach Beacon_Apex head;@modelswap ->123 shapesmileyface "
	);
}



// LibapxCommandPlay
// ================
// makes the main actor play an animation by applying an animgroup
// "@play reset" stops the animation
void LibapxCommandPlay(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	unitgroup g = u;
	string val;
	string flags = "";
	string animgroup;
	int paramOffset = 0;
	string target = LibapxACTORREFMAIN;

	// get actor reference target
	if( LibapxHasActorRef(StringWord(argv, 2)) ) {
		target = StringWord(argv, 2);
		paramOffset = 1;
	}

	val = StringWord(argv, 2 + paramOffset);
	val = StringCase(StringSub(val, 1, 1), true) + StringSub(val, 2, StringLength(val));

	// if @play [anim] [loop] , then set the flags for anim to PlayForever
	if( StringEqual(StringWord( argv, 3 + paramOffset), "loop", c_stringNoCase) ) {
		flags = "PlayForever";
		animgroup = StringWord(argv, 4 + paramOffset);
	}
	else {
		animgroup = StringWord(argv, 3 + paramOffset);
	}

	animgroup = StringCase(StringSub(animgroup, 1, 1), true) + StringSub(animgroup, 2, StringLength(animgroup));

	// apply animgroup actor msg to units
	if( StringSub(target, 1, 2) == "->" ) {
		target = StringSub(target, 3, StringLength(target));
		UnitGroupLoopBegin(g);
		while(!UnitGroupLoopDone()) {
			if( StringEqual(val, "reset", c_stringNoCase) ) {
				ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), target, "AnimClear " + "LibapxCommandPlay");
			}
			else {
				ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), target, "AnimPlay LibapxCommandPlay " + val + " " + flags);
				if(animgroup != "") {
					ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), target, "AnimGroupRemoveAll");
					ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), target, "AnimGroupApply {" + animgroup + "}");
				}
			}
			LibapxUnitCacheUpdate(UnitGroupLoopCurrent(), "@play", argv);
			UnitGroupLoopStep();
		}
		UnitGroupLoopEnd();
	}
	else { // "__[ref]", target global
		target = StringSub(target, 3, StringLength(target));
		UnitGroupLoopBegin(g);
		while(!UnitGroupLoopDone()) {
			if( StringEqual(val, "reset", c_stringNoCase) ) {
				ActorSend(ActorFrom(target), "AnimClear " + "LibapxCommandPlay");
			}
			else {
				ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), target, "AnimPlay LibapxCommandPlay " + val + " " + flags);
				if(animgroup != "") {
					ActorSend(ActorFrom(target), "AnimGroupRemoveAll");
					ActorSend(ActorFrom(target), "AnimGroupApply {" + animgroup + "}");
				}
			}
			UnitGroupLoopStep();
		}
		UnitGroupLoopEnd();
	}
	return;
}
void LibapxDefinePlay(string commandName) {
	LibapxCommandsGuideEntrySet(
		gv_CommandsGuideEntryActor, 
		commandName, 
		" This command plays animations on an actor. It can be used with target. The parameter loop makes the animation loop. <br> @play ->[target] [animations] [animations] <br> Examples: <br> @play attack <br> @play attack loop <br> @play walk loop <br> @play start loop <br> @play cover loop <br> @play burrow loop <br> @play x 00 <br> @play x 01 <br> @play walk,01 loop <br> @play x 02 "
	);
}



// LibapxCommandAnimspeed
// ===================
// changes the animation speed of any animations
// a unit is playing (range is set as 0-10x default, 1)
void LibapxCommandAnimspeed(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	string speed;
	fixed anmSpeed;
	int paramOffset = 0;
	string target = LibapxACTORREFMAIN;

	// get actor reference target
	if( LibapxHasActorRef(StringWord(argv, 2)) ) {
		target = StringWord(argv, 2);
		paramOffset = 1;
	}

	// get animspeed time scale. if % at end, then apply a percent scale
	speed = StringWord(argv, 2 + paramOffset);
	if( StringContains( speed, "%", c_stringEnd, c_stringCase ) ) {
		anmSpeed = StringToFixed( StringSub(speed, 1, StringLength(speed)-1) ) / 100;
	} else {
		anmSpeed = StringToFixed( speed );
	}

	// apply bounds for animspeed between 0 and 10
	if( anmSpeed < 0 ) {
		anmSpeed = 0;
	}
	else if(anmSpeed > 10) {
		anmSpeed = 10;
	}

	// apply the animspeed
	ApplyActormsg(u, target, argv, "@animspeed",
						  libNtve_gf_AnimSetTimeScaleGlobal(anmSpeed));

	return;
}
void LibapxDefineAnimspeed(string commandName) {
	LibapxCommandsGuideEntrySet(
		gv_CommandsGuideEntryActor, 
		commandName, 
		" This command sets the animation speed of an actor. It can be used with target. <br> @animspeed ->[target] [animationspeed] <br> Examples: <br> @animspeed 3 <br> @animspeed 5 <br> @animspeed 0 <br> @target 6;@attach marauder origin 0 0 3;@animspeed ->6 3 "
	);
}

// LibapxCommandRotate
// ==================
// applies a rotation on a unit (modified from Cortex Engine)
// (note: movement removes these rotations,
// so only really useful for static props)
void LibapxCommandRotate(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	fixed yaw;
	fixed pitch;
	fixed roll;
	fixed forwardX;
	fixed forwardY;
	fixed forwardZ;
	fixed upX;
	fixed upY;
	fixed upZ;
	int paramOffset = 0;
	string target = LibapxACTORREFMAIN;

	// get actor reference target
	if( LibapxHasActorRef(StringWord(argv, 2)) ) {
		target = StringWord(argv, 2);
		paramOffset = 1;
	}

	// calculate rotation vector parameters
	yaw = StringToFixed( StringWord(argv, 2 + paramOffset) );
	pitch = StringToFixed( StringWord(argv, 3 + paramOffset) );
	roll = StringToFixed( StringWord(argv, 4 + paramOffset) );

	forwardX = Sin(yaw);
	forwardY = -Sin(pitch) * Cos(yaw);
	forwardZ = Cos(pitch) * Cos(yaw);

	upX = -Cos(yaw) * Sin(roll);
	upY = -Sin(pitch) * Sin(yaw) * Sin(roll) + Cos(pitch) * Cos(roll);
	upZ = Cos(pitch) * Sin(yaw) * Sin(roll) + Sin(pitch) * Cos(roll);

	// apply the rotation actor msgs
	ApplyActormsg(u, target, argv, "@rotate",
						  libNtve_gf_SetRotation(forwardX, forwardY, forwardZ, upX, upY, upZ));
	return;
}
void LibapxDefineRotate(string commandName) {
	LibapxCommandsGuideEntrySet(
		gv_CommandsGuideEntryActor, 
		commandName, 
		" This command applies a rotation to a unit. It can be used with target. <br> Note: This rotation is removed if a unit moves. <br> @rotate  ->[target] [x] [y] [z] <br> Examples: <br> @rotation 90 <br> @target 123;@attach marine weapon;l@rotation ->123 90 "
	);
}




// LibapxCommandStatbars
// ==================
// sets a unit's statbars
// by default, turns statbars off.
// turns on if user specifies by "@statbars on"
void LibapxCommandStatbars(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	string state = "";
	int paramOffset = 0;
	string target = LibapxACTORREFMAIN;

	// get actor reference target
	if( LibapxHasActorRef(StringWord(argv, 2)) ) {
		target = StringWord(argv, 2);
		paramOffset = 1;
	}

	// get statbars state ("on" -> turn on, anything else turns off)
	if(StringEqual(StringWord(argv, 2 + paramOffset), "on", false)) {
		state = " 1"; // 1 == on
	}

	// apply the statbars actor msgs
	ApplyActormsg(u, target, argv, "@statbars", "SetShowStatusBar" + state);
	return;
}
void LibapxDefineStatbars(string commandName) {
	LibapxCommandsGuideEntrySet(
		gv_CommandsGuideEntryActor, 
		commandName, 
		" This command sets an actors statbars on or off. It can be used with target. <br> Note: If you give the command no parameters it, by default, will turn the statbars off on the actor. <br> @statbars  ->[target] [state] <br> Examples: <br> @statbars <br> @statbars on <br> @target 123;@attach marine head;@statbars ->123 "
	);
}


//LibapxCommandSetscaler
//==========================
//Sets the scale modifier for units, this intern is added in calcultions for
//@attach translations and scales.
void LibapxCommandSetscaler(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	fixed scaler;
	if (StringWord(argv,2) == "") {
		LibapxPrint(PlayerGroupSingle(user),"Input something");
	}
	else if (StringWord(argv,3) != "") {
		LibapxPrint(PlayerGroupSingle(user),"SetScaler only takes one value");
	}
	else if (LibapxIsFixed(StringWord(argv, 2)) == false) {
		LibapxPrint(PlayerGroupSingle(user),"SetScaler takes numbers");
	}
	else {
		LibapxPrint(PlayerGroupSingle(user),"Scaler set to "+StringWord(argv,2));
		scaler = StringToFixed(StringWord(argv,2));
		gv_LibapxPlayer[user].scaler = scaler;
	}


}
void LibapxDefineSetscaler(string commandName) {
	LibapxCommandsGuideEntrySet(
	 	gv_CommandsGuideEntryGeneral, 
		commandName, 
		" This command sets the default scale modifier for all units created after this point. This modifier multiplies against @scale, @actrmsg SetScale, @attach translations, and @actrmsg SetScaleAbsolute. <br> Note: The default scaler is 1 <br> @setscaler [newscale] <br> Examples: <br> @setscaler 3 <br> @setscaler .1 "
	);
}



//LibapxCommandSetdelay
//==========================
//Sets the default delay for attachments
void LibapxCommandSetdelay(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	fixed delay;
	if (StringWord(argv,2) == "") {
		LibapxPrint(PlayerGroupSingle(user),"Input something");
	}
	else if (StringWord(argv,3) != "") {
		LibapxPrint(PlayerGroupSingle(user),"SetDelay only takes one value");
	}
	else if (LibapxIsFixed(StringWord(argv, 2)) == false) {
		LibapxPrint(PlayerGroupSingle(user),"SetDelay takes numbers");
	}
	else {
		LibapxPrint(PlayerGroupSingle(user),"Delay set to "+StringWord(argv,2));
		delay = StringToFixed(StringWord(argv,2));
		gv_LibapxPlayer[user].delay = delay;
	}


}
void LibapxDefineSetdelay(string commandName) {
	LibapxCommandsGuideEntrySet(
	 	gv_CommandsGuideEntryGeneral, 
		commandName, 
		" This command sets the default delay for all @attach commands and Gamesetup loading delays. <br> Note: By default it is .08, additionally the gamesetup delay will never go below a minimium value. Regardless of what you set this. <br> @setdelay [newdelay] <br> Examples: <br> @setdelay 3 <br> @setdelay .1 "
	);
}

// LibapxCommandAttachMinus
// =====================
// Replicated old attach of Cortex
void LibapxCommandAttachMinus(int user, unitgroup u, string argv, int spawningCount, string bracketText) {

	actor sactor;
	string actr;
	string scope;
	string apoint;
	unitgroup g = u;
	int i;
	bool loop = true;
	string attachPoints = "Origin Center Damage Engine Hardpoint Head Hit Overhead RallyPoint StatusBar Left Right Target Turret TurretY TurretZ Upgrade Weapon WeaponLeft WeaponRight Left Right";



	//Colossus Check
	unitgroup p = u;
	int colcheker = 1;
	while (StringWord(argv, colcheker) != "") {
		if(StringFind(StringWord(argv, colcheker), "colossus", c_stringNoCase) != -1 ) {
				UnitGroupLoopBegin(p);
				while(!UnitGroupLoopDone()) {
					LibapxUnitFlagColossus(UnitGroupLoopCurrent());
					UnitGroupLoopStep();
				}
				UnitGroupLoopEnd();
		}
		colcheker = colcheker + 1;
	}



	LibapxWaitDelay(user);

	actr = StringWord(argv,2);
	apoint = StringWord(argv,3);

	//StringWord(argv,2); //1st , 2nd after ect
	if (apoint == "") {
		apoint = "Origin";
	}

	// Let's make sure that the apoint is a valid attachment point.

	i = 1;
	while( StringWord(attachPoints, i) != "" ) {
		if( StringEqual(apoint, StringWord(attachPoints, i), false) ) {
			apoint = StringWord(attachPoints, i);
			i = -1;
			break;
		}
		i = i + 1;
	}

	if( i != -1 ) {
		apoint = "Origin";
		LibapxPrintOutput(user, "Attachpoint was invalid, defaulting to origin");
	}

 // do catalog check for actor
	actr = LibapxCatalogGet(c_gameCatalogActor, actr);
	if(actr == null) {
		LibapxPrintOutput(user, "<c val=\"ff0000\">Unable to attach actor</c>: No such actor exists.");
		return;
	}
	scope = CatalogEntryScope( c_gameCatalogActor, actr );
	if( scope == "CActorEventMacro" || scope == "CActorSound" ) {
		LibapxPrintOutput(user, "<c val=\"ff0000\">Unable to attach actor</c>: Invalid actor.");
		return;
	}


		UnitGroupLoopBegin(g);
		while(!UnitGroupLoopDone())
		{
			// Attach the actor to the unit
			libNtve_gf_AttachActorToUnit(UnitGroupLoopCurrent(), actr, apoint);
			if(!StringContains(actr, "TalkIcon", c_stringAnywhere, c_stringNoCase)) {
					LibapxUnitCacheUpdate(UnitGroupLoopCurrent(), "@attach-", argv);
					LibapxUnitSetLastAttachVal(UnitGroupLoopCurrent(),"->::Main",apoint,"0","0,0,0","0,0,0","");
					//Reset for @rotator
					ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach_Current", "AliasRemove Apex_Attach_Current");
					ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach", "AliasAdd Apex_Attach_Irrelevant");
			}
			UnitGroupLoopStep();
		}
		UnitGroupLoopEnd();
}
void LibapxDefineAttachMinus(string commandName) {
	LibapxCommandsGuideEntrySet(
	 	gv_CommandsGuideEntryActor, 
		commandName, 
		" This command uses the old attach method, it is depreciated and generally has no reason to be used if you use @target with the modern @attach as they can emulate and surpass what attachdummy could do. <br> It is not compatible with target. <br> @attach- [actor] [point] <br> Examples: <br> @attach- marine head "
	);
}




// LibapxCommandAttach
// =====================
// Attaches an actor or a model to a unit (modified @attach+ from Cortex Forge)
// Can optionally specify coordinate offsets, rotations, and site operations
// syntax: @attach (->[ref]) (-m) [Actor/Model] [Point_#] [offX] [offY] [offZ] (-r [rotX] [rotY] [rotZ]) [SOp1] [SOp2] [SOp3]...
void LibapxCommandAttach(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	unitgroup g = u;
	int parseOffset = 0;
	int x;
	string actr = "{}";
	string model = "{}";
	string scope;
	string apoint;
	string apointIndex = "";
	string lastAttachPoint;
	string offset = null;
	string rotation = null;
	string SOp;
	string siteops = "";
	string actormsg;
	string attachPoints = "Origin Center Damage Engine Hardpoint Head Hit Overhead RallyPoint StatusBar Left Right Target Turret TurretY TurretZ Upgrade Weapon WeaponLeft WeaponRight Left Right";
	string target = LibapxACTORREFMAIN;
	unitgroup p = u;
	int colcheker = 1;
	bool nocache;
	bool noDelay; //Secret modifier, dont tell anyone. This negates all delays in cmd (for adjuster)

	if(StringFind( argv, "-nodelay",c_stringNoCase) != -1) {
		argv =  StringReplaceWord(argv, "-nodelay", "", 1, c_stringNoCase);
		noDelay = true;
	}

	if( StringFind(argv, "-nocache" ,c_stringNoCase) != -1 ) {
		argv =  StringReplaceWord(argv, "-nocache", "", 1, c_stringNoCase);
		LibapxPrintOutput(user, argv);
		nocache = true;
	}
	while (StringWord(argv, colcheker) != "") {
		if(StringFind(StringWord(argv, colcheker), "colossus", c_stringNoCase) != -1 ) {
				UnitGroupLoopBegin(p);
				while(!UnitGroupLoopDone()) {
					LibapxUnitFlagColossus(UnitGroupLoopCurrent());
					UnitGroupLoopStep();
				}
				UnitGroupLoopEnd();
		}
		colcheker = colcheker + 1;
	}
	if(!noDelay) {
		//Wait
		LibapxWaitDelay(user);
	}
	// get actor reference target
	if( LibapxHasActorRef(StringWord(argv, 2)) ) {
		target = StringWord(argv, 2);
		parseOffset = 1;
	}

	if(StringWord( argv, 2 + parseOffset) == "") {
		return;
	}
	else if(StringWord( argv, 2 + parseOffset) == "-m") {
		model = StringWord( argv, 3 + parseOffset);
	}
	else {
		actr = StringWord( argv, 2 + parseOffset);
	}

	if( actr == "listpoints" || model =="listpoints" ) {
		LibapxPrint(PlayerGroupSingle(user), "<c val=\"00ff00\">Available attach points</c>:<n/>" + attachPoints);
		return;
	}

	// check actor or model is valid
	if(StringWord( argv, 2 + parseOffset) == "-m") { //do catalog check for model
		model = LibapxCatalogGet(c_gameCatalogModel, model);
		if(model == null) {
			LibapxPrintOutput(user, "<c val=\"ff0000\">Unable to attach actor model</c>: No such model exists.");
			return;
		}
		parseOffset += 1; // increase parse offset since model "-m" flag being used
	}
	else { // do catalog check for actor
		actr = LibapxCatalogGet(c_gameCatalogActor, actr);
		if(actr == null) {
			LibapxPrintOutput(user, "<c val=\"ff0000\">Unable to attach actor</c>: No such actor exists.");
			return;
		}
		scope = CatalogEntryScope( c_gameCatalogActor, actr );
		if( scope == "CActorEventMacro" || scope == "CActorSound" ) {
			LibapxPrintOutput(user, "<c val=\"ff0000\">Unable to attach actor</c>: Invalid actor.");
			return;
		}
	}

	//MODIFY ATTACH POINT STRING:
	//get apoint (attachment point)
	apoint = StringWord( argv, 3 + parseOffset);
	if( apoint == "" ) {
		apoint = "Origin";
	}
	if(StringContains(apoint, "_", c_stringAnywhere, c_stringNoCase)) {
		x = StringLength(apoint);
		while(StringSub(apoint, x, x) != "_") {
			x -= 1;
		}
		apointIndex = " " + StringSub(apoint, x+1, StringLength(apoint));
		apoint = StringSub(apoint, 1, x-1);
	}
	//check apoint is valid
	x = 1;
	while( StringWord(attachPoints, x) != "" ) {
		if( StringEqual(apoint, StringWord(attachPoints, x), false) ) {
			apoint = StringWord(attachPoints, x);
			x = -1;
			break;
		}
		x = x + 1;
	}

	if( x != -1 ) {
		apoint = "Origin";
		LibapxPrintOutput(user, "<c val=\"ff0000\">Warning</c>: Invalid attachment point, defaulting to Origin.<n/>You can obtain a list of attachment points by typing <c val=\"00ff00\">@attach listpoints</c>.");
	}

	//remake the apoint string
	apoint = "{" + apoint + apointIndex + "}";

	//check for offset (if specified)
	if(StringWord( argv, 4 + parseOffset) != ""
		&& !StringContains(StringWord( argv, 4 + parseOffset), "SOp", c_stringAnywhere, c_stringNoCase)
		&& StringWord( argv, 4 + parseOffset) != "-r") {
		x = 0;
		offset = "";
		while(x < 3) {
			if(StringWord( argv, 4 + parseOffset + x) != "") {
				offset += "," + FixedToString(StringToFixed(StringWord( argv, 4 + parseOffset + x)), c_fixedPrecisionAny);
			}
			else {
				offset += ",0";
			}

			x += 1;
		}
		offset = StringSub(offset, 2, StringLength(offset));
		parseOffset += 3;
	}

	//check for local rotation (if specified)
	if(StringWord( argv, 4 + parseOffset) == "-r") {
		parseOffset += 1;
		x = 0;
		rotation = "";
		if(offset == null) {
			offset = "0,0,0";
		}
		while(x < 3) {
			if(StringWord( argv, 4 + parseOffset + x) != "") {
				rotation += "," + FixedToString(StringToFixed(StringWord( argv, 4 + parseOffset + x)), c_fixedPrecisionAny);
			}
			else {
				rotation += ",0";
			}

			x += 1;
		}
		rotation = StringSub(rotation, 2, StringLength(rotation));
		parseOffset += 3;
	}

	//keep checking for specified site ops until reached end of string
	if(StringWord( argv, 4 + parseOffset) != "") {
		x = 0;
		while(StringWord( argv, 4 + parseOffset + x) != "") {
			if(StringContains(StringWord( argv, 4 + parseOffset + x), "SOp", c_stringAnywhere, c_stringNoCase)) {
				SOp = StringWord( argv, 4 + parseOffset + x);
				SOp = LibapxCatalogGet(c_gameCatalogActor, SOp);
				if(SOp == null) {
					LibapxPrintOutput(user, "<c val=\"ff0000\">Warning: Encounted invalid or unknown Site Op: Skipping");
				}
				else {
					siteops = siteops + " " + SOp;
				}
			}
			x += 1;
		}
		if(siteops != "") {
			if(offset == null) {
				offset = "0,0,0";
			}
			if(rotation == null) {
				rotation = "{}";
			}
			siteops = StringSub(siteops, 2, StringLength(siteops));
			siteops = "{" + siteops + "}";
		}
	}

	//FINALLY create the actor msg (before send)

	actormsg = "AttachModelOffset " + actr + " " + model + " " + apoint; // "-ats","-ats head", "-ats Weapon_02"

	lastAttachPoint = StringReplaceWord(apoint,"{","",1,c_stringCase);
	lastAttachPoint = StringReplaceWord(lastAttachPoint,"}","",1,c_stringCase);
	// LibapxPrintOutput(user, lastAttachPoint);


	if(offset != null) {

		offset = LibapxScalerapply(offset, u, "", user);
		actormsg = actormsg + " " + offset;
	}
	if(rotation != null) {
		actormsg = actormsg + " " + rotation;
	}
	if(siteops != "") {
		actormsg = actormsg + " " + siteops;
	}




	
	// apply attach actor msg to units
	if( StringSub(target, 1, 2) == "->" ) {
		target = StringSub(target, 3, StringLength(target));
		UnitGroupLoopBegin(g);
		while(!UnitGroupLoopDone()) {
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), target, actormsg);
			LibapxUnitSetLastAttachVal(UnitGroupLoopCurrent(),target, StringWord(lastAttachPoint,1), StringWord(lastAttachPoint,2), offset, "0,0,0", siteops);
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach_Current", "AliasRemove Apex_Attach_Current");
				ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach", "AliasAdd Apex_Attach_Irrelevant");
				DataTableSetString(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), gv_LibapxUnitIndexId), 0) + "_Rotated", "no");
				DataTableSetString(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), gv_LibapxUnitIndexId), 0) + "_Offsetted", "no");
			if (offset == ""){
				offset = "0,0,0";
				LibapxUnitSetLastAttachVal(UnitGroupLoopCurrent(),target, StringWord(lastAttachPoint,1), StringWord(lastAttachPoint,2), offset, "0,0,0", siteops); //Saving coordinates for @rotator
				//Reset for @rotator
				ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach_Current", "AliasRemove Apex_Attach_Current");
				ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach", "AliasAdd Apex_Attach_Irrelevant");
				DataTableSetString(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), gv_LibapxUnitIndexId), 0) + "_Rotated", "no");
				DataTableSetString(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), gv_LibapxUnitIndexId), 0) + "_Offsetted", "no");
			}
			// TODO: need to generalize actors that shouldnt update cache
			if(!StringContains(actr, "TalkIcon", c_stringAnywhere, c_stringNoCase)) {
				if(!nocache) {
					LibapxUnitCacheUpdate(UnitGroupLoopCurrent(), "@attach", argv);
				}
			}
			UnitGroupLoopStep();
		}
		UnitGroupLoopEnd();
	}
	else { // "__[ref]", target global
		target = StringSub(target, 3, StringLength(target));
		UnitGroupLoopBegin(g);
		while(!UnitGroupLoopDone()) {
			ActorSend(ActorFrom(target), actormsg);
			//Reset for @rotator
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach_Current", "AliasRemove Apex_Attach_Current");
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach", "AliasAdd Apex_Attach_Irrelevant");
			LibapxUnitSetLastAttachVal(UnitGroupLoopCurrent(),target, StringWord(lastAttachPoint,1), StringWord(lastAttachPoint,2), offset, "0,0,0", siteops); //Saving coordinates for @rotator
			DataTableSetString(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), gv_LibapxUnitIndexId), 0) + "_Rotated", "no");
			DataTableSetString(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), gv_LibapxUnitIndexId), 0) + "_Offsetted", "no");
			UnitGroupLoopStep();
		}
		UnitGroupLoopEnd();
	}
	return;
}
void LibapxDefineAttach(string commandName) {
	LibapxCommandsGuideEntrySet(
	 	gv_CommandsGuideEntryActor, 
		commandName, 
		" This command attaches an actor to another actor. It is compatible with target. <br> @attach ->[target] [actor] [point] [x] [y] [z] -r [x] [y] [z]  <br> To Note: The x y z after -r is largely depreciated and now replaced by @rotation and it's functionality.  <br> You can find a list of actors to attach with _ search actor [name] <br> You can find a list of valid attachpoints with @attach listpoints  <br> You can check what points on a model with @checkpoints <br> the first [x] [y] [z] is how you attach a model with an offset <br> -nocache can be used with this command to stop it from caching in a unit's caches. <br> Examples: <br> (This would attach the actor 3 units ahead of where you attach.) <br> @attach marine origin 0 -3 0 <br>  (This would attach above where you attach) <br> @attach marine origin 0 0 4 <br> (This would go above and ahead of what you attach) <br> @attach marine origin 0 -3 5 <br> @target 123;@attach marine overhead;@attach ->123 marauder weapon 0 -3 "
	);
}



// LibapxCommandRotation
// =====================
//This command uses the "Apex_Rotator" model and actor with attachmodeloffset to achieve  x y and z rotations.
// ex @rotation 90x 35z 25x
// @rotation 32y
// Modifiers
// -ypr : switches from xyz to yaw/pitch/roll
// -b  : switches actor to beacon scaled actor

//Prototypes
void attachRotationX(int degrees, bool absScale, unit u, bool Model);
void attachRotationY(int degrees, bool absScale, unit u, bool Model);
void attachRotationZ(int degrees, bool absScale, unit u, bool Model);

void LibapxCommandAttachRotation(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	bool modYpr = false;
	bool modB = false;
	bool modM = false;
	int i;
	int j;
	string temp;
	bool nocache;
	unit tmpUnit;
	string presetCoords;

	if(StringFind( argv, "-nocache",c_stringNoCase) != -1) {
		argv =  StringReplaceWord(argv, "-nocache", "", 1, c_stringNoCase);
		nocache = true;
	}
	//Remove, and check for, modifiers.
	if( StringFind(argv, "-ypr", c_stringNoCase) != -1 ) {
		modYpr = true;
		argv = StringReplaceWord(argv, "-ypr",  "", 1, c_stringNoCase);
	} 

	if( StringFind(argv, "-b", c_stringNoCase) != -1 ) {
		modB = true;
		argv = StringReplaceWord(argv, "-b",  "", 1, c_stringNoCase);
	} 

	if( StringFind(argv, "-m", c_stringNoCase) != -1 ) {
		modM = true;
	} 

	
	if (modM) {
	UnitGroupLoopBegin(u);
	while(!UnitGroupLoopDone()) {
		if ( DataTableGetString(true,FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), gv_LibapxUnitIndexId), 0) + "_Rotated") != "yes"){
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach", "AliasAdd Apex_Attach_Irrelevant");
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"::Main", "RefSet ::scope.Host ::Host");
		} else {
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach", "AliasAdd Apex_Attach_Irrelevant"); //all existing Apex_Attach actors becomes "Old"
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"::Main", "RefSet ::scope.Host ::Host");
		}

		presetCoords = LibapxUnitGetLastAttachVal(UnitGroupLoopCurrent());

		ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach_Old", "AliasAdd Apex_Attach_Irrelevant"); //all existing Apex_Attach actors becomes "Old"
		//Step Two: copy the attachment of the current actor, but instead with an Apex_Attach model actor
		ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach", "AliasAdd Apex_Attach_Old"); //all existing Apex_Attach actors becomes "Old"
		ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"::Main", "AttachModelOffset Apex_Attach Invisible Origin 0,0,0"); //attaching the apex_attach actor first
		ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach", "AliasAdd Apex_Attach_New"); //now ALL Apex_Attach actors are labeled "New" including most recent one.
		ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach_Old", "AliasRemove Apex_Attach_New"); //all "Old" actors discard the "New" label EXCEPT the most recent
		ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach_New", "RefSet ::scope.RotatorHost"); //all "Old" actors discard the "New" label EXCEPT the most recent
		if ( DataTableGetString(true,FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), gv_LibapxUnitIndexId), 0) + "_Rotated") == "yes"){
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"::scope.Host", "AttachOffset Apex_Attach_New " + presetCoords); 
		} else {
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"::scope.Host", "AttachOffset Apex_Attach_New " + presetCoords); 
		}
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
}


	
	//Strings-words start at 1
	//1 = command
	//2 = starting syntx
	i = 2;
	while(StringWord(argv, i) != "") {
		//We break apart
		temp = StringWord(argv, i);
		if(modYpr) {
			if (StringFind(temp, "y", c_stringNoCase) != -1) {
				temp = StringReplace(temp, "", StringFind(temp, "y", c_stringNoCase), StringFind(temp, "y", c_stringNoCase) );

				for (j = 1; j <= UnitGroupCount(u, c_unitCountAll); j += 1) {
					 attachRotationZ(StringToInt(temp), !modB, UnitGroupUnit(u, j), modM);
				}
			}
			if (StringFind(temp, "p", c_stringNoCase) != -1) {

				temp = StringReplace(temp, "", StringFind(temp, "p", c_stringNoCase), StringFind(temp, "p", c_stringNoCase) );
	
				for (j = 1; j <= UnitGroupCount(u, c_unitCountAll); j += 1) {
					attachRotationY(StringToInt(temp), !modB, UnitGroupUnit(u, j), modM);
			   }
			}
			if (StringFind(temp, "r", c_stringNoCase) != -1) {

				temp = StringReplace(temp, "", StringFind(temp, "r", c_stringNoCase), StringFind(temp, "r", c_stringNoCase) );
	
				for (j = 1; j <= UnitGroupCount(u, c_unitCountAll); j += 1) {
					attachRotationX(StringToInt(temp), !modB, UnitGroupUnit(u, j), modM);
			   }
			}
		}
		else {
			if (StringFind(temp, "x", c_stringNoCase) != -1) {

				temp = StringReplace(temp, "", StringFind(temp, "x", c_stringNoCase), StringFind(temp, "x", c_stringNoCase) );
	
				for (j = 1; j <= UnitGroupCount(u, c_unitCountAll); j += 1) {
					 attachRotationX(StringToInt(temp), !modB, UnitGroupUnit(u, j), modM);
				}
				
			}
			if (StringFind(temp, "y", c_stringNoCase) != -1) {

				temp = StringReplace(temp, "", StringFind(temp, "y", c_stringNoCase), StringFind(temp, "y", c_stringNoCase) );
	
				for (j = 1; j <= UnitGroupCount(u, c_unitCountAll); j += 1) {
					attachRotationY(StringToInt(temp), !modB, UnitGroupUnit(u, j), modM);
			   }
			}
			if (StringFind(temp, "z", c_stringNoCase) != -1) {

				temp = StringReplace(temp, "", StringFind(temp, "z", c_stringNoCase), StringFind(temp, "z", c_stringNoCase) );
	
				for (j = 1; j <= UnitGroupCount(u, c_unitCountAll); j += 1) {
					attachRotationZ(StringToInt(temp), !modB, UnitGroupUnit(u, j), modM);
			   }
			}
		}
		i += 1;
	}

	//Reform argv
	if(modYpr) {
		argv = argv + " -ypr";
	}
	if(modB) {
		argv = argv + " -b";
	}
	for (j = 1; j <= UnitGroupCount(u, c_unitCountAll); j += 1) {
		if(!nocache) {
			LibapxUnitCacheUpdate(UnitGroupUnit(u, j), "@rotation", argv);
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupUnit(u, j)),"Apex_Attach", "AliasAdd Apex_Attach_Current"); //now ALL Apex_Attach actors are labeled "Current" including most recent one.
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupUnit(u, j)),"Apex_Attach_Irrelevant", "AliasRemove Apex_Attach_Current"); //all "Irrelevant" actors discard the "Current" label EXCEPT the most recent added
			DataTableSetString(true, FixedToString(UnitGetCustomValue(UnitGroupUnit(u, j), gv_LibapxUnitIndexId), 0) + "_Rotated", "yes");
			DataTableSetString(true, FixedToString(UnitGetCustomValue(UnitGroupUnit(u, j), gv_LibapxUnitIndexId), 0) + "_Offsetted", "no");
		}

	}

}
void LibapxDefineRotation(string commandName) {
	LibapxCommandsGuideEntrySet(
	 	gv_CommandsGuideEntryActor, 
		commandName, 
		" This command creates a new actor on top of what actor it is called on with a specified rotation. It is not compatible with target. <br> @rotation [modifiers] [rotations.. <br> @rotation can have it's functionality and inputs modified with three modifiers, these modifiers are <br> -b: This changes the end actor from a default actor to a Beacon_Apex actor <br> -ypr: This changes it's xyz inputs into yaw pitch roll inputs <br> -nocache: This makes the command no longer store in the units caches. <br> Examples: <br> @rotation 30y <br> @rotation 90y 10z <br> @rotation -b 90x 35z 190y <br> @rotation -ypr 90y 32p 15r "
	);
}
//Helper commands for rotation
void attachRotationX(int degrees, bool absScale, unit u, bool Model) {
	int pointNum;
	string attachPoint = "";
	string rotation = "0,0,0";
	//X is Target_01-08
	//Y is Hit_01-08
	//Z is Hardpoint_01-08
	string actorName = "Beacon_Apex";
	int degreesAbs = AbsI(degrees);
	if(absScale) {
		actorName = "Apex_Actor";
	}
	if(Model) {
        actorName = "Apex_Attach";
    }
	
	while(degreesAbs > 360 || degreesAbs == 360) {
		degreesAbs -= 360;
	}

	if(degrees < 0) {
		degrees = 360-degreesAbs;
	}
	else {
		degrees = degreesAbs;
	}

	//Generate Attach Point Based off of rotation amt
	pointNum = degrees/45 + 1;
	attachPoint = "{Target " + IntToString(pointNum) + "}";


	//point handles >45
	while(degrees > 45 || degrees == 45) {
		degrees -= 45;
	}


	//0 through 45 degree rotations are handled by attach model offset's rotation
	if (degrees != 0) {
		//Build rotation
		rotation = "0,-1,-" + FixedToString(Tan(degrees),9);
	}

	if (Model) {
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_Old"); //all existing Apex_Attach actors becomes "Old"
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachModelOffset "+actorName+" {} Origin 0,0,0"); //the "New" Apex_Attach actor attaches another
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_New"); //now ALL Apex_Attach actors are labeled "New" including most recent one.
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_Old", "AliasRemove Apex_Attach_New"); //all "Old" actors discard the "New" label EXCEPT the most recent
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "ModelSwap Apex_Rotator");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "SetScaleAbsolute 1");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "ModelAllowHitTest 0");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_Old"); //Again
		//AttachModelOffset " +attachment + " {} " + attachPoint + " " + offset + " " + rotation + " " + siteops
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachModelOffset "+actorName+" Invisible " + attachPoint + " 0,0,0 " + rotation); 
		//repeat process
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_New");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_Old", "AliasRemove Apex_Attach_New");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachOffset ::Main {Origin 0} 0,0,0");
	} else {
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"::Main", "ModelSwap Apex_Rotator");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"::Main", "SetScaleAbsolute 1");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"::Main", "ModelAllowHitTest 0");
		//AttachModelOffset " +attachment + " {} " + attachPoint + " " + offset + " " + rotation + " " + siteops
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"::Main", "AttachModelOffset "+actorName+" {} " + attachPoint + " 0,0,0 " + rotation);
	}

	attachRotationZ(270, absScale, u, Model);

}

void attachRotationZ(int degrees, bool absScale, unit u, bool Model) {
	int pointNum;
	string attachPoint = "";
	string rotation = "0,0,0";
	//X is Target_01-08
	//Y is Hit_01-08
	//Z is Hardpoint_01-08
	string actorName = "Beacon_Apex";
	int degreesAbs = AbsI(degrees);
	if(absScale) {
		actorName = "Apex_Actor";
	}
	if(Model) {
        actorName = "Apex_Attach";
    }
	while(degreesAbs > 360 || degreesAbs == 360) {
		degreesAbs -= 360;
	}

	if(degrees < 0) {
		degrees = 360-degreesAbs;
	}
	else {
		degrees = degreesAbs;
	}



	//Generate Attach Point Based off of rotation amt
	pointNum = degrees/45;
	attachPoint = "{Hardpoint " + IntToString(pointNum) + "}";


	//point handles >45
	while(degrees > 45 || degrees == 45) {
		degrees -= 45;
	}


	//0 through 45 degree rotations are handled by attach model offset's rotation
	if (degrees != 0) {
		//Build rotation
		rotation = "-1," + FixedToString(Tan(degrees+90),9) + ",0";
	}



	if (Model) {
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_Old"); //all existing Apex_Attach actors becomes "Old"
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachModelOffset "+actorName+" {} Origin 0,0,0"); //the "New" Apex_Attach actor attaches another
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_New"); //now ALL Apex_Attach actors are labeled "New" including most recent one.
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_Old", "AliasRemove Apex_Attach_New"); //all "Old" actors discard the "New" label EXCEPT the most recent
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "ModelSwap Apex_Rotator");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "SetScaleAbsolute 1");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "ModelAllowHitTest 0");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_Old"); //Again
		//AttachModelOffset " +attachment + " {} " + attachPoint + " " + offset + " " + rotation + " " + siteops
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachModelOffset "+actorName+" Invisible " + attachPoint + " 0,0,0 " + rotation); 
		//repeat process
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_New");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_Old", "AliasRemove Apex_Attach_New");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachOffset ::Main {Origin 0} 0,0,0");
	} else {
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"::Main", "ModelSwap Apex_Rotator");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"::Main", "SetScaleAbsolute 1");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"::Main", "ModelAllowHitTest 0");
		//AttachModelOffset " +attachment + " {} " + attachPoint + " " + offset + " " + rotation + " " + siteops
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"::Main", "AttachModelOffset "+actorName+" {} " + attachPoint + " 0,0,0 " + rotation);
	}
}
void attachRotationY(int degrees, bool absScale, unit u, bool Model) {
	int pointNum;
	string attachPoint = "";
	string rotation = "0,0,0";
	//X is Target_01-08
	//Y is Hit_01-08
	//Z is Hardpoint_01-08
	string actorName = "Beacon_Apex";
	int degreesAbs = AbsI(degrees);
	if(absScale) {
		actorName = "Apex_Actor";
	}
	if(Model) {
        actorName = "Apex_Attach";
    }
	while(degreesAbs > 360 || degreesAbs == 360) {
		degreesAbs -= 360;
	}

	if(degrees < 0) {
		degrees = 360-degreesAbs;
	}
	else {
		degrees = degreesAbs;
	}



	//Generate Attach Point Based off of rotation amt
	pointNum = degrees/45+1;
	attachPoint = "{Hit " + IntToString(pointNum) + "}";


	//point handles >45
	while(degrees > 45 || degrees == 45) {
		degrees -= 45;
	}


	//0 through 45 degree rotations are handled by attach model offset's rotation
	if (degrees != 0) {
		//Build rotation
		rotation = "0,-1,-" + FixedToString(Tan(degrees),9);
	}



	if (Model) {
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_Old"); //all existing Apex_Attach actors becomes "Old"
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachModelOffset "+actorName+" {} Origin 0,0,0"); //the "New" Apex_Attach actor attaches another
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_New"); //now ALL Apex_Attach actors are labeled "New" including most recent one.
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_Old", "AliasRemove Apex_Attach_New"); //all "Old" actors discard the "New" label EXCEPT the most recent
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "ModelSwap Apex_Rotator");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "SetScaleAbsolute 1");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "ModelAllowHitTest 0");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_Old"); //Again
		//AttachModelOffset " +attachment + " {} " + attachPoint + " " + offset + " " + rotation + " " + siteops
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachModelOffset "+actorName+" Invisible " + attachPoint + " 0,0,0 " + rotation); 
		//repeat process
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_New");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_Old", "AliasRemove Apex_Attach_New");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachOffset ::Main {Origin 0} 0,0,0");
	} else {
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"::Main", "ModelSwap Apex_Rotator");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"::Main", "SetScaleAbsolute 1");
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"::Main", "ModelAllowHitTest 0");
		//AttachModelOffset " +attachment + " {} " + attachPoint + " " + offset + " " + rotation + " " + siteops
		ActorSendTo(libNtve_gf_MainActorofUnit(u),"::Main", "AttachModelOffset "+actorName+" {} " + attachPoint + " 0,0,0 " + rotation);
	}
}







































// LibapxCommandOffset
// =====================
// Offsets the ::Main actor by default off the actor it's currently hosted by
// Can optionally specify attachpoints, coordinate offsets, coordinate rotations, (and site operations??)
// syntax: @offset (->[ref]) [Point_#] [offX] [offY] [offZ] [rotX] [rotY] [rotZ] [SOp1] [SOp2] [SOp3]...
void LibapxCommandOffset(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	unitgroup g = u;
	int parseOffset = 0;
	int x;
	string actr = "{}";
	string model = "{}";
	string scope;
	string apoint;
	string apointIndex = "";
	string offset = null;
	string rotation = null;
	string SOp;
	string siteops = "";
	string actormsg;
	string attachPoints = "Origin Center Damage Engine Hardpoint Head Hit Overhead RallyPoint StatusBar Left Right Target Turret TurretY TurretZ Upgrade Weapon WeaponLeft WeaponRight Left Right Attacher";
	string presetCoords;
	unitgroup p = u;
	int colcheker = 1;
	bool nocache;
	bool noDelay; //Secret modifier, dont tell anyone. This negates all delays in cmd (for adjuster)

	fixed scaler = gv_LibapxPlayer[user].scaler;
	 //I think Sero fucking uses this for x,y,z for some reason. 
	// use attachPoints to noCaseSensitive common points. Otherwise use the input as is.
	string attPoint = StringWord(argv,2);
	string attPointNum = StringWord(argv,3);
	 //Actually we're going to try the string sub or replace to shift the input offset for attpointnum. If no underscore, then will not take a attach point input.
	// set the offsets to 0,0,0 if none are given also have it give the exact argv if setscaler isn't 1.
	string offsetX = null;
	string offsetY = null;
	string offsetZ = null;
	// set the rotations to 0,0,0 if none are given
	string rotX = null;
	string rotY = null;
	string rotZ = null;
	// string target = LibapxACTORREFMAIN;
	string target = "->::Host";
	string val;
	int paramOffset;
	string siteOps = LibapxBracketTextGrab(bracketText, 1);


	// Correct all SiteOps in bracketText
	if(StringWord(siteOps,1) != "") {
		x = 0;
		while(StringWord(siteOps,1 + x) != "") {
			SOp = StringWord(siteOps,1 + x);
			SOp = LibapxCatalogGet(c_gameCatalogActor, SOp);
			if(SOp == null) {
				LibapxPrintOutput(user, "<c val=\"ff0000\">Warning: Encounted invalid or unknown Site Op: Skipping");
								
			} else {
				siteOps = StringReplaceWord(siteOps,StringWord(siteOps,1 + x),SOp,c_stringReplaceAll,c_stringNoCase);
			}
			x += 1;
		}
	}

	
	// Sets the paramoffets if ->::Target is detected
	if( LibapxHasActorRef(StringWord(argv, 2)) ) {
		target = StringWord(argv, 2);
		paramOffset = 1;
	}
	val = StringWord(argv, 2 + paramOffset);
	val = StringCase(StringSub(val, 1, 1), true) + StringSub(val, 2, StringLength(val));


	// Compatability with some of the original AttachOffset formatting, (eg. 0.05,1,20 = 0.05 1 20)
	argv = StringReplaceWord(argv,","," ",4,c_stringNoCase);


	// Sets the attach point number to the 2nd part of the first argument (eg. Weapon_02 = "Weapon")
	attPoint = StringWord(StringReplaceWord(StringWord(argv,2 + paramOffset),"_"," ",1,c_stringNoCase),1);


	// Predetermined attach points gets no-case-sensitivity benefits :)
	x = 1;
	while( StringWord(attachPoints, x) != "" ) {
		if( StringEqual(attPoint, StringWord(attachPoints, x), false) ) {
			attPoint = StringWord(attachPoints, x);
			x = -1;
			break;
		}
		x = x + 1;
	}


	// Sets the attach point number to the second part of the first argument (eg. Weapon_02 = "02") else defaults zero.
	if (StringContains(StringWord(argv,2 + paramOffset),"_",c_stringAnywhere,c_stringNoCase)) {
		attPointNum = StringWord(StringReplaceWord(StringWord(argv,2 + paramOffset),"_"," ",1,c_stringNoCase),2);
	} else {
		attPointNum = "0";
	}


	// Sets the arguement offsets
	offsetX = StringWord(argv,3 + paramOffset);
	offsetY = StringWord(argv,4 + paramOffset);
	offsetZ = StringWord(argv,5 + paramOffset);
	rotX = StringWord(argv,6 + paramOffset);
	rotY = StringWord(argv,7 + paramOffset);
	rotZ = StringWord(argv,8 + paramOffset);


	// Sets the defaults
	if(attPoint ==""){
		attPoint = "Origin";
	}
	if(attPointNum ==""){
		attPointNum = "0";
	}
	if(offsetX ==""){
		offsetX = "0";
	}
	if(offsetY ==""){
		offsetY = "0";
	}
	if(offsetZ ==""){
		offsetZ = "0";
	}
	if(rotX ==""){
		rotX = "0";
	}
	if(rotY ==""){
		rotY = "0";
	}
	if(rotZ ==""){
		rotZ = "0";
	}


	//idk these might become features
	if(StringFind( argv, "-nodelay",c_stringNoCase) != -1) {
		argv =  StringReplaceWord(argv, "-nodelay", "", 1, c_stringNoCase);
		noDelay = true;
	}
	if( StringFind(argv, "-nocache" ,c_stringNoCase) != -1 ) {
		argv =  StringReplaceWord(argv, "-nocache", "", 1, c_stringNoCase);
		LibapxPrintOutput(user, argv);
		nocache = true;
	}
	if(!noDelay) {
		//Wait
		LibapxWaitDelay(user);
	}


	// Reapplies commas for the actual actrsmg syntax
	offset = offsetX + "," + offsetY  + "," + offsetZ;
	offset = LibapxScalerapply(offset, u, "", user); //Applies scaler. Might be broken.


	// actormsg = "->" + target + "AttachOffset ::Main {Head 0} 0,0,0 0,0,0";
	actormsg = "AttachOffset ::Main {"+ attPoint +" "+ attPointNum +"} " + offset + " " + rotX + "," + rotY + "," + rotZ + " {" + siteOps + "}" ;


	  //basically the only way I can get it to save a setscaler'd offset 
	 // scratch that, it's so dumb. Attach/Attach-/Scale don't actually cache the manipulated offset values
	//  i misremembered the fact that my reposition alias uses variables, which DO save scaled values. :/
	// if (scaler != 1){
	// argv = StringReplaceWord(argv, offsetX + " " + offsetY + " " + offsetZ, offset, 1, c_stringCase);
	// }


	// Actual Function 
	if( StringSub(target, 1, 2) == "->" ) {
		target = StringSub(target, 3, StringLength(target));
	UnitGroupLoopBegin(g);
		while(!UnitGroupLoopDone()) {
			presetCoords = LibapxUnitGetLastAttachVal(UnitGroupLoopCurrent());
			
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()), target, actormsg);
			DataTableSetString(true, FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), gv_LibapxUnitIndexId), 0) + "_Offsetted", "yes");
			if (bracketText != "") {
				LibapxUnitCacheUpdate(UnitGroupLoopCurrent(), "@offset", argv + " [" + siteOps + "]"); // if there are SOps
				if ( DataTableGetString(true,FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), gv_LibapxUnitIndexId), 0) + "_Rotated") == "yes"){ 
					LibapxUnitSetLastAttachVal(UnitGroupLoopCurrent(),target, StringReplaceWord(StringWord(presetCoords,1),"{","",1,c_stringNoCase), attPointNum, offset, rotX + "," + rotY + "," + rotZ , siteOps); //Saving coordinates for @rotator
				} else {
					LibapxUnitSetLastAttachVal(UnitGroupLoopCurrent(),target, attPoint, attPointNum, offset, rotX + "," + rotY + "," + rotZ , siteOps);
				}
			} else {
				LibapxUnitCacheUpdate(UnitGroupLoopCurrent(), "@offset", argv); // else without SOps
				if ( DataTableGetString(true,FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), gv_LibapxUnitIndexId), 0) + "_Rotated") == "yes"){ 
					LibapxUnitSetLastAttachVal(UnitGroupLoopCurrent(),target, StringReplaceWord(StringWord(presetCoords,1),"{","",1,c_stringNoCase), attPointNum, offset, rotX + "," + rotY + "," + rotZ , siteOps); //Saving coordinates for @rotator
				} else {
					LibapxUnitSetLastAttachVal(UnitGroupLoopCurrent(),target, attPoint, attPointNum, offset, rotX + "," + rotY + "," + rotZ , siteOps);
				}
			}
			UnitGroupLoopStep();
			// LibapxPrintOutput(user, target + actormsg);
		}
		UnitGroupLoopEnd();
	} else { // "__[ref]", target global
	target = StringSub(target, 3, StringLength(target));
	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		ActorSend(ActorFrom(target), actormsg);
		LibapxUnitCacheUpdate(UnitGroupLoopCurrent(), "@offset", argv);
		LibapxUnitSetLastAttachVal(UnitGroupLoopCurrent(),target, attPoint, attPointNum, offset, rotX + "," + rotY + "," + rotZ , siteOps); //Saving coordinates for @rotator
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	
}
return;


}
void LibapxDefineOffset(string commandName) {
	LibapxCommandsGuideEntrySet(
	 	gv_CommandsGuideEntryActor, 
		commandName, 
		" This command repositions the current actor to its host/attaching actor. It is compatible with target. <br> @offset ->[target] [point] [number(optional)] [x] [y] [z] [x] [y] [z] [[SOp....]] <br> To Note: The second set of x y z represents what coordinates the actor should face on a cartesian plane. <br> Also Note: syntax is compatible with original comma separators. <br> You can find a list of valid attachpoints with @attach listpoints  <br> the first [x] [y] [z] is how you attach a model with an offset <br> can insert any number of SOp's in brackets []'s. <br> Examples: <br> (This would reposition the current actor 3 units ahead of where you attach.) <br> @offset origin 0 -3 0 <br> @offset target_02 [sop90] <br> (This would make the current attached actor rotate forwards 45 degrees) <br> @offset origin 0,0,0 0,-1,-1"
	);
}

// LibapxCommandRotator
// =====================
//This command uses the "Apex_Attach" model and actor with attachmodeloffset to achieve  x y and z rotations.
// I do not want to override the @rotation cmd so duplicating will have to do for now.
// ex. @rotator 21x
// @rotator 11y 37x

//Prototypes
void attachRotatorX(int degrees, bool absScale, unit u, bool modelAttach);
void attachRotatorY(int degrees, bool absScale, unit u, bool modelAttach);
void attachRotatorZ(int degrees, bool absScale, unit u, bool modelAttach);

void LibapxCommandNewAttachRotation(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
    bool modYpr = false;
    bool modB = false;
    int i;
    int j;
    string temp;
	string presetCoords;
    bool nocache;
    bool useModel;
    unit tmpUnit;
    if(StringFind( argv, "-nocache",c_stringNoCase) != -1) {
        argv =  StringReplaceWord(argv, "-nocache", "", 1, c_stringNoCase);
        nocache = true;
    }
    if(StringFind( argv, "-m",c_stringNoCase) != -1) {
        argv =  StringReplaceWord(argv, "-m", "", 1, c_stringNoCase);
        useModel = true;
    }
    //Remove, and check for, modifiers.
    if( StringFind(argv, "-ypr", c_stringNoCase) != -1 ) {
        modYpr = true;
        argv = StringReplaceWord(argv, "-ypr",  "", 1, c_stringNoCase);
    } 

    if( StringFind(argv, "-b", c_stringNoCase) != -1 ) {
        modB = true;
        argv = StringReplaceWord(argv, "-b",  "", 1, c_stringNoCase);
    } 




	UnitGroupLoopBegin(u);
	while(!UnitGroupLoopDone()) {
		//Starting by making all older ones irrelevant by default.
		// ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"::Main", "HaloStart"); //TEST

		if ( DataTableGetString(true,FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), gv_LibapxUnitIndexId), 0) + "_Rotated") != "yes"){
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"::Main", "RefSet ::scope.Host ::Host");
		} else if ( DataTableGetString(true,FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), gv_LibapxUnitIndexId), 0) + "_Offsetted") != "yes") {
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach_Current", "Destroy"); //Destroy current rotating actors
		} else {
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach", "AliasAdd Apex_Attach_Irrelevant"); //all existing Apex_Attach actors becomes "Old"
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"::Main", "RefSet ::scope.Host ::Host");
		}

		presetCoords = LibapxUnitGetLastAttachVal(UnitGroupLoopCurrent());

		ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach_Old", "AliasAdd Apex_Attach_Irrelevant"); //all existing Apex_Attach actors becomes "Old"
		//Step Two: copy the attachment of the current actor, but instead with an Apex_Attach model actor
		ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach", "AliasAdd Apex_Attach_Old"); //all existing Apex_Attach actors becomes "Old"
		ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"::Main", "AttachModelOffset Apex_Attach Invisible Origin 0,0,0"); //attaching the apex_attach actor first
		ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach", "AliasAdd Apex_Attach_New"); //now ALL Apex_Attach actors are labeled "New" including most recent one.
		ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach_Old", "AliasRemove Apex_Attach_New"); //all "Old" actors discard the "New" label EXCEPT the most recent
		ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach_New", "RefSet ::scope.RotatorHost"); //all "Old" actors discard the "New" label EXCEPT the most recent
		if ( DataTableGetString(true,FixedToString(UnitGetCustomValue(UnitGroupLoopCurrent(), gv_LibapxUnitIndexId), 0) + "_Rotated") == "yes"){
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"::scope.Host", "AttachOffset Apex_Attach_New " + presetCoords); 
		} else {
			ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"::scope.Host", "AttachOffset Apex_Attach_New " + presetCoords); 
		}
		
		// LibapxPrintOutput(user, "->::Host AttachOffset Apex_Attach_New " + LibapxUnitGetLastAttachVal(UnitGroupLoopCurrent()));

		//Step Three: IDK
		// ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach", "AliasAdd Apex_Attach_Old"); //all existing Apex_Attach actors becomes "Old"
		// ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach_New", "AttachModelOffset Apex_Attach Invisible Origin 0,0,0"); //the "New" Apex_Attach actor attaches another
		// ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach", "AliasAdd Apex_Attach_New"); //now ALL Apex_Attach actors are labeled "New" including most recent one.
		// ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),"Apex_Attach_Old", "AliasRemove Apex_Attach_New"); //all "Old" actors discard the "New" label EXCEPT the most recent
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
    //Strings-words start at 1
    //1 = command
    //2 = starting syntx
    i = 2;
    while(StringWord(argv, i) != "") {
        //We break apart
        temp = StringWord(argv, i);
        if(modYpr) {
            if (StringFind(temp, "y", c_stringNoCase) != -1) {
                temp = StringReplace(temp, "", StringFind(temp, "y", c_stringNoCase), StringFind(temp, "y", c_stringNoCase) );

                for (j = 1; j <= UnitGroupCount(u, c_unitCountAll); j += 1) {
                     attachRotatorZ(StringToInt(temp), !modB, UnitGroupUnit(u, j),useModel);
                }
            }
            if (StringFind(temp, "p", c_stringNoCase) != -1) {

                temp = StringReplace(temp, "", StringFind(temp, "p", c_stringNoCase), StringFind(temp, "p", c_stringNoCase) );
    
                for (j = 1; j <= UnitGroupCount(u, c_unitCountAll); j += 1) {
                    attachRotatorY(StringToInt(temp), !modB, UnitGroupUnit(u, j),useModel);
               }
            }
            if (StringFind(temp, "r", c_stringNoCase) != -1) {

                temp = StringReplace(temp, "", StringFind(temp, "r", c_stringNoCase), StringFind(temp, "r", c_stringNoCase) );
    
                for (j = 1; j <= UnitGroupCount(u, c_unitCountAll); j += 1) {
                    attachRotatorX(StringToInt(temp), !modB, UnitGroupUnit(u, j),useModel);
               }
            }
        }
        else {
            if (StringFind(temp, "x", c_stringNoCase) != -1) {

                temp = StringReplace(temp, "", StringFind(temp, "x", c_stringNoCase), StringFind(temp, "x", c_stringNoCase) );
    
                for (j = 1; j <= UnitGroupCount(u, c_unitCountAll); j += 1) {
                     attachRotatorX(StringToInt(temp), !modB, UnitGroupUnit(u, j),useModel);
                }
                
            }
            if (StringFind(temp, "y", c_stringNoCase) != -1) {

                temp = StringReplace(temp, "", StringFind(temp, "y", c_stringNoCase), StringFind(temp, "y", c_stringNoCase) );
    
                for (j = 1; j <= UnitGroupCount(u, c_unitCountAll); j += 1) {
                    attachRotatorY(StringToInt(temp), !modB, UnitGroupUnit(u, j),useModel);
               }
            }
            if (StringFind(temp, "z", c_stringNoCase) != -1) {

                temp = StringReplace(temp, "", StringFind(temp, "z", c_stringNoCase), StringFind(temp, "z", c_stringNoCase) );
    
                for (j = 1; j <= UnitGroupCount(u, c_unitCountAll); j += 1) {
                    attachRotatorZ(StringToInt(temp), !modB, UnitGroupUnit(u, j),useModel);
               }
            }
        }
        i += 1;
    }

    //Reform argv
    if(modYpr) {
        argv = argv + " -ypr";
    }
    if(modB) {
        argv = argv + " -b";
    }
    for (j = 1; j <= UnitGroupCount(u, c_unitCountAll); j += 1) {
        if(!nocache) {
            LibapxUnitCacheUpdate(UnitGroupUnit(u, j), "@rotator", argv);
        }
		ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupUnit(u, j)),"Apex_Attach", "AliasAdd Apex_Attach_Current"); //now ALL Apex_Attach actors are labeled "Current" including most recent one.
		ActorSendTo(libNtve_gf_MainActorofUnit(UnitGroupUnit(u, j)),"Apex_Attach_Irrelevant", "AliasRemove Apex_Attach_Current"); //all "Irrelevant" actors discard the "Current" label EXCEPT the most recent added
		DataTableSetString(true, FixedToString(UnitGetCustomValue(UnitGroupUnit(u, j), gv_LibapxUnitIndexId), 0) + "_Rotated", "yes");
		DataTableSetString(true, FixedToString(UnitGetCustomValue(UnitGroupUnit(u, j), gv_LibapxUnitIndexId), 0) + "_Offsetted", "no");
		// LibapxUnitSetLastAttachVal(UnitGroupUnit(u, j),"::Host", "Origin", "", "", "", "");
    }
	

}
void LibapxDefineNewRotation(string commandName) {
    LibapxCommandsGuideEntrySet(
        gv_CommandsGuideEntryActor, 
        commandName, 
        " This command rotates the current ::Main actor <br> by attaching ModelAddition actors <br> which should not interfere with the actor <br> heirarchy like @rotation would <br> <c val=\"FFE5C9\">Modifiers:</c> <br> -ypr: This changes it's xyz inputs into yaw pitch roll inputs <br> <c val=\"FFFF00\">-nocache:</c> This makes the command no longer store in the units caches. <br> <c val=\"FFE5C9\">Examples:</c> <br> @rotator 30y <br> @rotator 90y 10z <br> @rotator 90x 35z 190y <br> @rotator -ypr 90y 32p 15r "    
	);
}
//Helper commands for rotation
void attachRotatorX(int degrees, bool absScale, unit u, bool useModel) {
    int pointNum;
    string attachPoint = "";
    string rotation = "0,0,0";
    //X is Target_01-08
    //Y is Hit_01-08
    //Z is Hardpoint_01-08
    string actorName = "Beacon_Apex";
    int degreesAbs = AbsI(degrees);
    if(absScale) {
        actorName = "Apex_Attach";
    }
    while(degreesAbs > 360 || degreesAbs == 360) {
        degreesAbs -= 360;
    }

    if(degrees < 0) {
        degrees = 360-degreesAbs;
    }
    else {
        degrees = degreesAbs;
    }

    //Generate Attach Point Based off of rotation amt
    pointNum = degrees/45 + 1;
    attachPoint = "{Target " + IntToString(pointNum) + "}";


    //point handles >45
    while(degrees > 45 || degrees == 45) {
        degrees -= 45;
    }


    //0 through 45 degree rotations are handled by attach model offset's rotation
    if (degrees != 0) {
        //Build rotation
        rotation = "0,-1,-" + FixedToString(Tan(degrees),9);
    }

	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_Old"); //all existing Apex_Attach actors becomes "Old"
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachModelOffset "+actorName+" {} Origin 0,0,0"); //the "New" Apex_Attach actor attaches another
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_New"); //now ALL Apex_Attach actors are labeled "New" including most recent one.
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_Old", "AliasRemove Apex_Attach_New"); //all "Old" actors discard the "New" label EXCEPT the most recent
    ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "ModelSwap Apex_Rotator");
    ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "SetScaleAbsolute 1");
    ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "ModelAllowHitTest 0");
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_Old"); //Again
    //AttachModelOffset " +attachment + " {} " + attachPoint + " " + offset + " " + rotation + " " + siteops
    ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachModelOffset "+actorName+" Invisible " + attachPoint + " 0,0,0 " + rotation); 
	//repeat process
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_New");
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_Old", "AliasRemove Apex_Attach_New");
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachOffset ::Main {Origin 0} 0,0,0");

	attachRotatorZ(270, absScale, u, useModel);
}

void attachRotatorZ(int degrees, bool absScale, unit u, bool modelAttach) {
    int pointNum;
    string attachPoint = "";
    string rotation = "0,0,0";
    //X is Target_01-08
    //Y is Hit_01-08
    //Z is Hardpoint_01-08
    string actorName = "Beacon_Apex";
    int degreesAbs = AbsI(degrees);
    if(absScale) {
        actorName = "Apex_Attach";
    }
    while(degreesAbs > 360 || degreesAbs == 360) {
        degreesAbs -= 360;
    }

    if(degrees < 0) {
        degrees = 360-degreesAbs;
    }
    else {
        degrees = degreesAbs;
    }



    //Generate Attach Point Based off of rotation amt
    pointNum = degrees/45;
    attachPoint = "{Hardpoint " + IntToString(pointNum) + "}";


    //point handles >45
    while(degrees > 45 || degrees == 45) {
        degrees -= 45;
    }


    //0 through 45 degree rotations are handled by attach model offset's rotation
    if (degrees != 0) {
        //Build rotation
        rotation = "-1," + FixedToString(Tan(degrees+90),9) + ",0";
    }


	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_Old"); //all existing Apex_Attach actors becomes "Old"
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachModelOffset "+actorName+" {} Origin 0,0,0"); //the "New" Apex_Attach actor attaches another
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_New"); //now ALL Apex_Attach actors are labeled "New" including most recent one.
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_Old", "AliasRemove Apex_Attach_New"); //all "Old" actors discard the "New" label EXCEPT the most recent
    ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "ModelSwap Apex_Rotator");
    ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "SetScaleAbsolute 1");
    ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "ModelAllowHitTest 0");
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_Old"); //Again
    //AttachModelOffset " +attachment + " {} " + attachPoint + " " + offset + " " + rotation + " " + siteops
    ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachModelOffset "+actorName+" Invisible " + attachPoint + " 0,0,0 " + rotation); 
	//repeat process
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_New");
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_Old", "AliasRemove Apex_Attach_New");
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachOffset ::Main {Origin 0} 0,0,0");
}
void attachRotatorY(int degrees, bool absScale, unit u, bool modelAttach) {
    int pointNum;
    string attachPoint = "";
    string rotation = "0,0,0";
    //X is Target_01-08
    //Y is Hit_01-08
    //Z is Hardpoint_01-08
    string actorName = "Beacon_Apex";
    int degreesAbs = AbsI(degrees);
    if(absScale) {
        actorName = "Apex_Attach";
    }
    while(degreesAbs > 360 || degreesAbs == 360) {
        degreesAbs -= 360;
    }

    if(degrees < 0) {
        degrees = 360-degreesAbs;
    }
    else {
        degrees = degreesAbs;
    }



    //Generate Attach Point Based off of rotation amt
    pointNum = degrees/45+1;
    attachPoint = "{Hit " + IntToString(pointNum) + "}";


    //point handles >45
    while(degrees > 45 || degrees == 45) {
        degrees -= 45;
    }


    //0 through 45 degree rotations are handled by attach model offset's rotation
    if (degrees != 0) {
        //Build rotation
        rotation = "0,-1,-" + FixedToString(Tan(degrees),9);
    }


	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_Old"); //all existing Apex_Attach actors becomes "Old"
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachModelOffset "+actorName+" {} Origin 0,0,0"); //the "New" Apex_Attach actor attaches another
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_New"); //now ALL Apex_Attach actors are labeled "New" including most recent one.
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_Old", "AliasRemove Apex_Attach_New"); //all "Old" actors discard the "New" label EXCEPT the most recent
    ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "ModelSwap Apex_Rotator");
    ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "SetScaleAbsolute 1");
    ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "ModelAllowHitTest 0");
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_Old"); //Again
    //AttachModelOffset " +attachment + " {} " + attachPoint + " " + offset + " " + rotation + " " + siteops
    ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachModelOffset "+actorName+" Invisible " + attachPoint + " 0,0,0 " + rotation); 
	//repeat process
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach", "AliasAdd Apex_Attach_New");
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_Old", "AliasRemove Apex_Attach_New");
	ActorSendTo(libNtve_gf_MainActorofUnit(u),"Apex_Attach_New", "AttachOffset ::Main {Origin 0} 0,0,0");

}




//LibapxCommandGet
//==========================
//Sets the default delay for attachments
void LibapxCommandGet(int user, unitgroup u, string argv, int spawningCount, string bracketText) {
	int indexCount;
	int i = 6; //this is just because " Model[" has 6 chars
	int end = 0;
	text infoText;
	string infoString;
	string category;
	string findBracket;
	string choice;
	//Target Actor
	string target = "::Main";
	string val;
	int paramOffset;

	if (UnitGroupCount(u, c_unitCountAlive) > 1) {
        LibapxPrintError(user, "Command can only be used on one unit.");
        return;
    }
	

	if( LibapxHasActorRef(StringWord(argv, 2)) ) {
		target = StringReplaceWord(StringWord(argv, 2),"->","",1,c_stringNoCase);
		paramOffset = 1;
	}
	val = StringWord(argv, 2 + paramOffset);
	val = StringCase(StringSub(val, 1, 1), true) + StringSub(val, 2, StringLength(val));

	category = StringWord(argv,2 + paramOffset);




	if (StringWord(argv,2) == "" ){
		LibapxPrintError(user,"Please Provide a Field  Input");
		LibapxPrintText(PlayerGroupSingle(user),StringToText("<c val=\"1abc9c\">Usage</c>: @get ( Model | Actor | SiteOps | Host | Full )"));
		return;
	}
	


	// TODO: Add a function to find all available fields.


	UnitGroupLoopBegin(u);
	while(!UnitGroupLoopDone()) {
		category = category + "[";
		i = StringLength(category);
		infoText = ActorGetText(ActorFromActor(libNtve_gf_MainActorofUnit(UnitGroupLoopCurrent()),target));
		infoString = TextToString(infoText);

		if (StringContains(category,"Full",c_stringAnywhere,c_stringNoCase)){
			LibapxPrintOutput(user,"<c val=\"1abc9c\">Actor Properties:</c><n>" + StringReplaceWord(StringReplaceWord(infoString,"]","<c val=\"1abc9c\">]<n>",c_stringReplaceAll,c_stringCase),"[","[</c>",c_stringReplaceAll,c_stringCase));
			return;
		}
		else if (StringContains(category,"Model",c_stringAnywhere,c_stringNoCase)){
		choice = "Actor Model: ";
		}
		else if (StringContains(category,"Actor",c_stringAnywhere,c_stringNoCase)){
			LibapxPrintOutput(user,"<c val=\"1abc9c\">Actor: " + StringReplaceWord(StringReplaceWord(StringWord(infoString,4),"]","<c val=\"1abc9c\">]",c_stringReplaceAll,c_stringCase),"[","[</c>",c_stringReplaceAll,c_stringCase));
			return;
		}
		else if (category == "" || !StringContains(infoString,category,c_stringAnywhere,c_stringNoCase)){
			LibapxPrintError(user,"Field Unavailable");
			LibapxPrintText(PlayerGroupSingle(user),StringToText("<c val=\"1abc9c\">Usage</c>: @get ( Model | Actor | SiteOps | Host | Full )"));
			return;
		} 
		else {
			choice = "Actor" + category + ":";
		}
		
		indexCount = StringFind(infoString,category,c_stringNoCase) -1;
		
		//make a loop that keeps increasing a number based on string position until it finds a closing bracket ("]")
		for (i = indexCount; findBracket != "]"; i+=1 ) {
			findBracket = StringSub(infoString, i,i);
			// LibapxPrintOutput(user,findBracket);
			end = end + 1;
		}

		infoString = StringSub(infoString, indexCount + StringLength(category), indexCount + end);
		infoString = StringSub(infoString,2,StringLength(infoString)-2);

		//Actual Result
		LibapxPrintOutput(user, "<c val=\"1abc9c\">" + choice + "</c> " + infoString);

		// // Debug Count Print
		// LibapxPrintOutput(user,IntToString(indexCount + StringLength(category)));
		// LibapxPrintOutput(user,IntToString(indexCount + i));


		UnitGroupLoopStep();
		
	}
	UnitGroupLoopEnd();

	

	
	


}
void LibapxDefineGet(string commandName) {
	LibapxCommandsGuideEntrySet(
	 	gv_CommandsGuideEntryGeneral, 
		commandName, 
		"Provides select information about the unit (eg. Model) <br> @get [...] <br> Examples: <br> @get actor <br> @get ->base model "
	);
}








































































